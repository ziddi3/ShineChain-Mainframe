<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Secret Chamber - ShineChain</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            overflow: hidden;
            background: #000;
        }

        #secret-canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .chamber-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #8A2BE2;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #8A2BE2;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
        }

        .chamber-title {
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #8A2BE2;
        }

        .mystical-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 32px;
            text-align: center;
            text-shadow: 0 0 20px #FFD700;
            opacity: 0;
            animation: fadeInOut 4s ease-in-out infinite;
            pointer-events: none;
            z-index: 999;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .exit-portal {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border-radius: 30px;
            border: 3px solid #FFD700;
            font-size: 18px;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.6);
            transition: all 0.3s;
        }

        .exit-portal:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 0 50px rgba(102, 126, 234, 0.9);
        }

        .particle-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
        }

        .controls-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            padding: 10px 20px;
            border-radius: 15px;
            border: 2px solid #00ffff;
            font-family: 'Courier New', monospace;
            z-index: 1000;
        }

        .interaction-prompt {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            font-size: 20px;
            z-index: 2000;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }
    </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
    <div class="chamber-hud">
        <div class="chamber-title">ðŸ”® The Secret Chamber</div>
        <div id="chamber-info">Ancient knowledge surrounds you...</div>
        <div id="objects-found">Mystical Objects: <span id="object-count">0</span>/5</div>
    </div>

    <div class="mystical-text" id="mysticalText">
        "In the depths of knowledge, secrets await..."
    </div>

    <div class="controls-hint">
        Mouse = Look Around | Click Objects = Interact | WASD = Move
    </div>

    <div class="interaction-prompt" id="interactionPrompt">
        Click to examine the mystical artifact
    </div>

    <button class="exit-portal" onclick="exitChamber()">
        ðŸŒ€ Return to Library
    </button>

    <canvas id="secret-canvas"></canvas>
    <canvas class="particle-overlay" id="particles"></canvas>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Card System -->
    <script src="assets/cards/card-data.js"></script>
    <script src="assets/cards/card-system.js"></script>
    <script src="assets/cards/card-placer.js"></script>

    <script>
        // Scene setup
        let scene, camera, renderer;
        let mysticalObjects = [];
        let objectsFound = 0;
        let playerPosition = new THREE.Vector3(0, 1.6, 5);
        let yaw = 0, pitch = 0;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.FogExp2(0x0a0a0a, 0.05);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(playerPosition);

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('secret-canvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Lighting - mystical purple/blue ambiance
            const ambientLight = new THREE.AmbientLight(0x4a148c, 0.3);
            scene.add(ambientLight);

            // Central mystical light
            const centralLight = new THREE.PointLight(0x8A2BE2, 2, 30);
            centralLight.position.set(0, 5, 0);
            scene.add(centralLight);

            // Rotating colored lights
            const colors = [0xFF00FF, 0x00FFFF, 0xFFD700, 0xFF1493];
            for (let i = 0; i < 4; i++) {
                const light = new THREE.PointLight(colors[i], 1, 15);
                const angle = (i / 4) * Math.PI * 2;
                light.position.set(
                    Math.cos(angle) * 8,
                    3,
                    Math.sin(angle) * 8
                );
                light.name = `rotatingLight${i}`;
                scene.add(light);
            }

            // Floor - mystical pattern
            const floorGeometry = new THREE.CircleGeometry(15, 64);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a0033,
                roughness: 0.7,
                metalness: 0.3
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Add mystical circle pattern
            const circleGeometry = new THREE.RingGeometry(5, 5.2, 64);
            const circleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8A2BE2,
                side: THREE.DoubleSide
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            circle.rotation.x = -Math.PI / 2;
            circle.position.y = 0.01;
            scene.add(circle);

            // Ceiling
            const ceilingGeometry = new THREE.CircleGeometry(15, 64);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a,
                roughness: 0.9
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 10;
            scene.add(ceiling);

            // Create mystical objects
            createMysticalObjects();

            // Create floating crystals
            createFloatingCrystals();

            // Create energy field
            createEnergyField();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            // Pointer lock
            document.getElementById('secret-canvas').addEventListener('click', () => {
                document.getElementById('secret-canvas').requestPointerLock();
            });

            // Initialize particle system
            initParticles();

            animate();
        }

        function createMysticalObjects() {
            const objectTypes = [
                { geometry: new THREE.OctahedronGeometry(0.5), color: 0xFF00FF, name: 'Crystal Octahedron' },
                { geometry: new THREE.IcosahedronGeometry(0.5), color: 0x00FFFF, name: 'Cosmic Icosahedron' },
                { geometry: new THREE.DodecahedronGeometry(0.5), color: 0xFFD700, name: 'Golden Dodecahedron' },
                { geometry: new THREE.TetrahedronGeometry(0.6), color: 0xFF1493, name: 'Pink Tetrahedron' },
                { geometry: new THREE.TorusKnotGeometry(0.4, 0.15, 100, 16), color: 0x8A2BE2, name: 'Eternal Knot' }
            ];

            objectTypes.forEach((type, index) => {
                const material = new THREE.MeshStandardMaterial({ 
                    color: type.color,
                    emissive: type.color,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const mesh = new THREE.Mesh(type.geometry, material);
                const angle = (index / objectTypes.length) * Math.PI * 2;
                mesh.position.set(
                    Math.cos(angle) * 6,
                    2 + Math.sin(index) * 0.5,
                    Math.sin(angle) * 6
                );
                mesh.userData = { 
                    name: type.name,
                    interactive: true,
                    rotationSpeed: 0.01 + Math.random() * 0.02
                };
                mesh.castShadow = true;
                scene.add(mesh);
                mysticalObjects.push(mesh);
            });
        }

        function createFloatingCrystals() {
            const crystalGeometry = new THREE.ConeGeometry(0.2, 0.8, 6);
            const crystalMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00FFFF,
                emissive: 0x00FFFF,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.7
            });

            for (let i = 0; i < 20; i++) {
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(
                    (Math.random() - 0.5) * 20,
                    2 + Math.random() * 6,
                    (Math.random() - 0.5) * 20
                );
                crystal.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                crystal.userData.floatSpeed = 0.5 + Math.random();
                crystal.userData.floatOffset = Math.random() * Math.PI * 2;
                scene.add(crystal);
            }
        }

        function createEnergyField() {
            const geometry = new THREE.TorusGeometry(8, 0.1, 16, 100);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x8A2BE2,
                transparent: true,
                opacity: 0.3
            });
            const torus = new THREE.Mesh(geometry, material);
            torus.rotation.x = Math.PI / 2;
            torus.position.y = 1;
            torus.name = 'energyField';
            scene.add(torus);
        }

        function initParticles() {
            const canvas = document.getElementById('particles');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: Math.random() * 3 + 1,
                    color: ['#8A2BE2', '#FF00FF', '#00FFFF', '#FFD700'][Math.floor(Math.random() * 4)]
                });
            }

            function animateParticles() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                    if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = 0.6;
                    ctx.fill();
                });
                
                requestAnimationFrame(animateParticles);
            }
            
            animateParticles();
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === document.getElementById('secret-canvas')) {
                yaw -= event.movementX * 0.002;
                pitch -= event.movementY * 0.002;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for object hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(mysticalObjects);
            
            if (intersects.length > 0 && intersects[0].object.userData.interactive) {
                document.getElementById('interactionPrompt').style.display = 'block';
                document.body.style.cursor = 'pointer';
            } else {
                document.getElementById('interactionPrompt').style.display = 'none';
                document.body.style.cursor = 'default';
            }
        }

        function onMouseClick() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(mysticalObjects);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.interactive) {
                    interactWithObject(object);
                }
            }
        }

        function interactWithObject(object) {
            objectsFound++;
            document.getElementById('object-count').textContent = objectsFound;
            
            // Animate object collection
            const originalScale = object.scale.clone();
            const interval = setInterval(() => {
                object.scale.multiplyScalar(1.1);
                object.rotation.y += 0.2;
            }, 50);
            
            setTimeout(() => {
                clearInterval(interval);
                object.visible = false;
                mysticalObjects = mysticalObjects.filter(o => o !== object);
                
                // Show mystical message
                const messages = [
                    "The ancient wisdom flows through you...",
                    "Reality bends to your will...",
                    "You've unlocked a fragment of truth...",
                    "The cosmos recognizes your presence...",
                    "Power courses through the chamber..."
                ];
                document.getElementById('mysticalText').textContent = messages[objectsFound - 1];
            }, 1000);

            if (objectsFound === 5) {
                setTimeout(() => {
                    alert('ðŸŽ‰ You have discovered all mystical artifacts! The chamber\'s secrets are yours!');
                }, 2000);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const canvas = document.getElementById('particles');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function updateMovement(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            const direction = new THREE.Vector3();
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 15.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 15.0 * delta;

            const rotatedVelocity = velocity.clone();
            rotatedVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

            playerPosition.add(rotatedVelocity.multiplyScalar(delta));

            // Keep player in chamber
            const distanceFromCenter = Math.sqrt(playerPosition.x ** 2 + playerPosition.z ** 2);
            if (distanceFromCenter > 12) {
                playerPosition.normalize().multiplyScalar(12);
            }

            camera.position.copy(playerPosition);
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            updateMovement(delta);

            // Rotate mystical objects
            mysticalObjects.forEach(obj => {
                obj.rotation.y += obj.userData.rotationSpeed;
                obj.rotation.x += obj.userData.rotationSpeed * 0.5;
                obj.position.y += Math.sin(time * 2 + obj.position.x) * 0.01;
            });

            // Rotate energy field
            const energyField = scene.getObjectByName('energyField');
            if (energyField) {
                energyField.rotation.z += 0.005;
            }

            // Rotate colored lights
            for (let i = 0; i < 4; i++) {
                const light = scene.getObjectByName(`rotatingLight${i}`);
                if (light) {
                    const angle = (i / 4) * Math.PI * 2 + time * 0.5;
                    light.position.x = Math.cos(angle) * 8;
                    light.position.z = Math.sin(angle) * 8;
                }
            }

            // Animate floating crystals
            scene.children.forEach(child => {
                if (child.userData.floatSpeed) {
                    child.position.y += Math.sin(time * child.userData.floatSpeed + child.userData.floatOffset) * 0.01;
                    child.rotation.y += 0.01;
                }
            });
            
            renderer.render(scene, camera);
        }

        function exitChamber() {
            document.body.style.transition = 'opacity 1s';
            document.body.style.opacity = '0';
            setTimeout(() => {
                window.location.href = 'library.html';
            }, 1000);
        }

        window.addEventListener('load', () => {
            init();
            
            // Place special cards in secret room
            setTimeout(() => {
                cardPlacer.placeCard('card_004', {
                    position: 'fixed',
                    top: '10%',
                    right: '10%',
                    rotation: 25,
                    animation: 'spin'
                });

                cardPlacer.placeCard('card_007', {
                    position: 'fixed',
                    bottom: '15%',
                    left: '10%',
                    rotation: -15,
                    animation: 'bounce'
                });
            }, 2000);
        });
    </script>
</body>
</html>