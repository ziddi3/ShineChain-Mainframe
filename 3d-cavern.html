<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShineChain 3D Cavern - Immersive Experience</title>
    
    <meta name="description" content="Enter the ShineChain 3D Cavern - An immersive first-person experience with interactive Tarot, Murmur Box, and Codex systems.">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffd700;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            z-index: 1000;
            max-width: 300px;
        }

        #controls-help {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00ffff;
            padding: 15px 30px;
            border-radius: 20px;
            border: 2px solid #00ffff;
            text-align: center;
            z-index: 1000;
        }

        #interaction-prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            font-size: 20px;
            z-index: 2000;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            color: #ffd700;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 14px;
            opacity: 0.7;
        }

        #click-to-start {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2500;
            color: #ffd700;
            cursor: pointer;
        }

        .start-button {
            padding: 20px 40px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #000;
            border: none;
            border-radius: 30px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        .back-button {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            border-radius: 25px;
            color: #ffd700;
            text-decoration: none;
            font-weight: bold;
            z-index: 1000;
            transition: all 0.3s;
        }

        .back-button:hover {
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        @media (max-width: 768px) {
            #info-overlay {
                font-size: 12px;
                padding: 10px;
                max-width: 200px;
            }

            #controls-help {
                font-size: 12px;
                padding: 10px 20px;
            }
        }
    </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">üåå Initializing ShineChain 3D Cavern</div>
        <div class="loading-progress" id="loading-progress">Loading assets...</div>
    </div>

    <!-- Click to Start -->
    <div id="click-to-start">
        <h1 style="font-size: 48px; margin-bottom: 20px;">üèõÔ∏è ShineChain 3D Cavern</h1>
        <p style="font-size: 18px; margin-bottom: 30px; opacity: 0.8;">An Immersive First-Person Experience</p>
        <button class="start-button" onclick="startExperience()">Enter the Cavern</button>
        <p style="font-size: 14px; margin-top: 30px; opacity: 0.6;">Click to enable controls and audio</p>
    </div>

    <!-- Back Button -->
    <a href="index.html" class="back-button">‚Üê Back to Holodeck</a>

    <!-- Info Overlay -->
    <div id="info-overlay">
        <h3 style="margin-bottom: 10px;">üåå 3D Cavern</h3>
        <div id="position-info">Position: (0, 0, 0)</div>
        <div id="fps-counter">FPS: 60</div>
        <div style="margin-top: 10px; font-size: 12px; opacity: 0.7;">
            Explore to find interactive objects
        </div>
    </div>

    <!-- Controls Help -->
    <div id="controls-help">
        <strong>Controls:</strong> WASD = Move | Mouse = Look | Click = Interact | ESC = Menu
    </div>

    <!-- Interaction Prompt -->
    <div id="interaction-prompt">
        Press E to interact
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>

    <!-- Main 3D Cavern Engine -->
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let clock, raycaster, mouse;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let canJump = false;
        let prevTime = performance.now();
        let interactiveObjects = [];
        let currentIntersect = null;

        // Initialize the 3D environment
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0a, 0.015);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Clock for animations
            clock = new THREE.Clock();

            // Raycaster for interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            createLighting();

            // Create cavern environment
            createCavern();

            // Create interactive objects
            createInteractiveObjects();

            // Add particle system
            createParticles();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('click-to-start').style.display = 'flex';
            }, 2000);
        }

        function createLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Main point light (golden)
            const mainLight = new THREE.PointLight(0xffd700, 1.5, 50);
            mainLight.position.set(0, 10, 0);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            scene.add(mainLight);

            // Additional colored lights
            const colors = [0xff00ff, 0x00ffff, 0xff6600];
            const positions = [
                [-15, 5, -15],
                [15, 5, -15],
                [0, 5, -30]
            ];

            colors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 0.8, 30);
                light.position.set(...positions[i]);
                scene.add(light);
            });
        }

        function createCavern() {
            // Floor
            const floorGeometry = new THREE.CircleGeometry(40, 64);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a0a0a,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Ceiling
            const ceilingGeometry = new THREE.CircleGeometry(40, 64);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                side: THREE.DoubleSide
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.y = 15;
            ceiling.rotation.x = Math.PI / 2;
            scene.add(ceiling);

            // Cavern walls (procedural)
            const wallSegments = 32;
            const wallRadius = 40;
            const wallHeight = 15;

            for (let i = 0; i < wallSegments; i++) {
                const angle = (i / wallSegments) * Math.PI * 2;
                const nextAngle = ((i + 1) / wallSegments) * Math.PI * 2;

                const x1 = Math.cos(angle) * wallRadius;
                const z1 = Math.sin(angle) * wallRadius;
                const x2 = Math.cos(nextAngle) * wallRadius;
                const z2 = Math.sin(nextAngle) * wallRadius;

                const wallGeometry = new THREE.PlaneGeometry(
                    Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2),
                    wallHeight
                );
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2a1a1a,
                    roughness: 0.9,
                    side: THREE.DoubleSide
                });
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                
                wall.position.set((x1 + x2) / 2, wallHeight / 2, (z1 + z2) / 2);
                wall.lookAt(0, wallHeight / 2, 0);
                wall.receiveShadow = true;
                wall.castShadow = true;
                
                scene.add(wall);
            }

            // Add some rock formations
            for (let i = 0; i < 10; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 1, 0);
                const rockMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3a2a2a,
                    roughness: 0.9
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 15;
                rock.position.set(
                    Math.cos(angle) * distance,
                    Math.random() * 2,
                    Math.sin(angle) * distance
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                
                scene.add(rock);
            }
        }

        function createInteractiveObjects() {
            // Tarot Reader (floating orb)
            const tarotGeometry = new THREE.SphereGeometry(1, 32, 32);
            const tarotMaterial = new THREE.MeshStandardMaterial({
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 0.5,
                roughness: 0.3,
                metalness: 0.7
            });
            const tarotOrb = new THREE.Mesh(tarotGeometry, tarotMaterial);
            tarotOrb.position.set(-10, 3, -10);
            tarotOrb.castShadow = true;
            tarotOrb.userData = { type: 'tarot', name: 'Tarot Reader' };
            scene.add(tarotOrb);
            interactiveObjects.push(tarotOrb);

            // Add glow to tarot orb
            const tarotGlow = new THREE.PointLight(0xff00ff, 2, 10);
            tarotGlow.position.copy(tarotOrb.position);
            scene.add(tarotGlow);

            // Murmur Box (crystalline obelisk)
            const murmurGeometry = new THREE.BoxGeometry(1.5, 4, 1.5);
            const murmurMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.4,
                roughness: 0.2,
                metalness: 0.8,
                transparent: true,
                opacity: 0.9
            });
            const murmurBox = new THREE.Mesh(murmurGeometry, murmurMaterial);
            murmurBox.position.set(10, 2, -10);
            murmurBox.rotation.y = Math.PI / 4;
            murmurBox.castShadow = true;
            murmurBox.userData = { type: 'murmur', name: 'Murmur Box' };
            scene.add(murmurBox);
            interactiveObjects.push(murmurBox);

            // Add glow to murmur box
            const murmurGlow = new THREE.PointLight(0x00ffff, 2, 10);
            murmurGlow.position.copy(murmurBox.position);
            scene.add(murmurGlow);

            // Codex (floating book)
            const codexGroup = new THREE.Group();
            
            // Book pages
            const pageGeometry = new THREE.BoxGeometry(2, 0.1, 3);
            const pageMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.3,
                roughness: 0.5
            });
            const pages = new THREE.Mesh(pageGeometry, pageMaterial);
            codexGroup.add(pages);

            // Book cover
            const coverGeometry = new THREE.BoxGeometry(2.2, 0.3, 3.2);
            const coverMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.8
            });
            const cover = new THREE.Mesh(coverGeometry, coverMaterial);
            cover.position.y = 0.2;
            codexGroup.add(cover);

            codexGroup.position.set(0, 3, -15);
            codexGroup.castShadow = true;
            codexGroup.userData = { type: 'codex', name: 'The Codex' };
            scene.add(codexGroup);
            interactiveObjects.push(codexGroup);

            // Add glow to codex
            const codexGlow = new THREE.PointLight(0xffd700, 2, 10);
            codexGlow.position.copy(codexGroup.position);
            scene.add(codexGlow);
        }

        function createParticles() {
            const particleCount = 200;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                // Random position within cavern
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 35;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = Math.random() * 15;
                positions[i + 2] = Math.sin(angle) * radius;

                // Golden color with variation
                colors[i] = 1.0;
                colors[i + 1] = 0.84 + Math.random() * 0.16;
                colors[i + 2] = Math.random() * 0.3;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);

            // Animate particles
            function animateParticles() {
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                    if (positions[i] > 15) positions[i] = 0;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }

            setInterval(animateParticles, 50);
        }

        function startExperience() {
            document.getElementById('click-to-start').style.display = 'none';
            
            // Request pointer lock
            renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                     renderer.domElement.mozRequestPointerLock ||
                                                     renderer.domElement.webkitRequestPointerLock;
            renderer.domElement.requestPointerLock();
            
            animate();
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += 5; canJump = false; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === renderer.domElement) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                camera.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }

            // Update mouse position for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick() {
            if (currentIntersect) {
                handleInteraction(currentIntersect.object);
            }
        }

        function handleInteraction(object) {
            const type = object.userData.type;
            const name = object.userData.name;

            alert(`Interacting with ${name}!\n\nFull ${type} interface coming in next phase...`);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateMovement(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 5.0 * delta; // Gravity

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;

            // Apply camera rotation to movement
            const euler = new THREE.Euler(0, camera.rotation.y, 0, 'YXZ');
            const rotatedVelocity = velocity.clone().applyEuler(euler);

            camera.position.add(rotatedVelocity.multiplyScalar(delta));

            // Keep player in bounds
            const maxDistance = 35;
            const distance = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
            if (distance > maxDistance) {
                camera.position.x = (camera.position.x / distance) * maxDistance;
                camera.position.z = (camera.position.z / distance) * maxDistance;
            }

            // Floor collision
            if (camera.position.y < 1.6) {
                velocity.y = 0;
                camera.position.y = 1.6;
                canJump = true;
            }

            // Update position display
            document.getElementById('position-info').textContent = 
                `Position: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`;
        }

        function checkInteractions() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            if (intersects.length > 0) {
                currentIntersect = intersects[0];
                document.getElementById('interaction-prompt').style.display = 'block';
            } else {
                currentIntersect = null;
                document.getElementById('interaction-prompt').style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            updateMovement(delta);
            checkInteractions();

            // Animate interactive objects
            interactiveObjects.forEach((obj, i) => {
                obj.rotation.y += 0.01;
                obj.position.y += Math.sin(time * 0.001 + i) * 0.005;
            });

            // Update FPS counter
            const fps = Math.round(1 / delta);
            document.getElementById('fps-counter').textContent = `FPS: ${fps}`;

            renderer.render(scene, camera);
            prevTime = time;
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>

    <!-- Card System Integration -->
    <script src="assets/cards/card-data.js"></script>
    <script src="assets/cards/card-system.js"></script>
</body>
</html>